{
  "common": {
    "header": {
      "searchText": "Пошук",
      "nav": {
        "home": "Головна",
        "labPz": "ЛБ & ПЗ"
      }
    }
  },
  "homePage": {
    "tagline": {
      "span": "ФОРМАЛЬНІ",
      "methods": "МЕТОДИ",
      "other": "ІНЖЕНЕРІЇ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ"
    },
    "subtitle": {
      "first": "Вивчайте ключові методи моделювання, розробки та верифікації складних програмних продуктів",
      "second": "для надійних та безпечних рішень."
    },
    "startBtn": "Почати вчитися"
  },
  "docsPage": {
    "fimpzLearn": "ВИВЧЕННЯ ФІМПЗ",
    "structure": "СТРУКТУРА",
    "menuTree": {
      "practicalWork": {
        "label": "Практичні роботи",
        "pz1": {
          "label": "Практичне № 1",
          "goal": "Мета заняття",
          "theoreticalInformation": "Методичні вказівки",
          "provingPartialCorrectnessLoop": "Доведення часткової коректності циклу",
          "cycleDiagramPremise": "Загальна схема циклу з передумовою",
          "definitionCycleInvariant": "Інваріанта циклу",
          "howChooseInvariants": "Як вибирати інваріанти?",
          "provingCorrectnessCycle": "Доведення повної коректності циклу",
          "ruleCorrectProgramming": "Правило коректного програмування",
          "controlQuestionsAndTasks": "Контрольні запитання і завдання",
          "examplesClassroomAndHomeworkTasks": "Приклади аудиторних і домашніх задач"
        },
        "pz2": {
          "label": "Практичне № 2",
          "goal": "Мета заняття"
        }
      },
      "laboratoryWork": {
        "label": "Лабораторні роботи",
        "lb1": {
          "label": "Лабораторна № 1",
          "goal": "Мета заняття",
          "theoreticalInformation": "Теоретичні відомості",
          "usageOpenJML": "Використання OpenJML",
          "testingCustomizedUtility": "Тестування налаштованої утиліти",
          "problemStatement": "Постановка задачі",
          "variantsIndividualTasks": "Варіанти індивідувальних завдань",
          "controlQuestionsTasks": "Контрольні запитання і завдання",
          "listOfReferences": "Перелік посилань"
        },
        "lb2": {
          "label": "Лабораторна № 2",
          "goal": "Мета заняття",
          "preparingWorkKeY": "Підготовка до роботи з KeY",
          "provingStatementsHelpKeY": "Доведення тверджень за допомгою KeY",
          "variantsIndividualTasks": "Варіанти індивідувальних завдань",
          "controlQuestionsTasks": "Контрольні запитання і завдання",
          "listOfReferences": "Перелік посилань"
        },
        "lb3": {
          "label": "Лабораторна № 3",
          "goal": "Мета заняття",
          "guidelinesForIndependentWork": "Методичні вказівки з організації самостійної роботи студентів",
          "spinPackage": "Пакет Spin",
          "spinOnWindows": "Використання Spin на платформі Windows",
          "correctnessModel": "Перевірка коректності моделі на основі LTL",
          "classesOfPropertiesDistributedSystems": "Класи властивостей розподілених систем",
          "spinOperatorsLTL": "Оператори Spin у LTL",
          "optionsIndividualTasks": "Варіанти індивідуальних завдань",
          "controlQuestionsAndTasks": "Контрольні запитання і завдання",
          "listOfReferences": "Перелік посилань"
        }
      },
      "other": {
        "label": "Інше",
        "pythonLesson": {
          "label": "Програмування Python",
          "goal": "Мета заняття",
          "mainIdeaContractProgramming": "Основна ідея контрактного програмування",
          "pyContractsPackage": "Пакет PyContracts",
          "pyContractsOnUbuntu": "Приклад встановлення та використання PyContracts на Ubuntu:",
          "pyContractsOnWindows": "Приклад встановлення та використання PyContracts на Windows:",
          "installationSteps": "Кроки встановлення",
          "testing": "Тестування налаштованої утиліти",
          "mistakes": "Помилки, які є в прикладі вище:",
          "problemStatement": "Постановка задачі",
          "individualTasks": "Варіанти індивідуальних завдань",
          "controlQuestions": "Контрольні запитання і завдання"
        }
      }
    },
    "content": {
      "goalLesson": "Мета заняття",
      "pz": {
        "pz1": {
          "main": {
            "label": "Дедуктивна верифікація програм",
            "goal": "Тренування навичок у доведенні коректності ітеративних програм на основі передумов, постумов та інваріант циклів."
          },
          "methodical": {
            "label": "Методичні вказівки з організації самостійної роботи студентів",
            "textOne": "Цикли, як правило, є найбільш складною частиною методів, більшість помилок пов’язана саме з ними. Під час написання циклів, які працюють коректно, вкрай важливо розуміти і використовувати терміни:",
            "pOne": "Інваріанта циклу",
            "pTwo": "Варіанта циклу",
            "textTwo": "Без них не обходиться формальний доказ коректності циклів. Але і неформальне розуміння правильності роботи програми засновується на цих термінах."
          },
          "provingPartialCorrectnessLoop": {
            "label": "Доведення часткової коректності циклу",
            "textOne": "Розглянемо цикл у формі, до якої можна привести всі види циклів: x – входи, z - виходи:",
            "pTitle": "Тут",
            "pOne": "B — умова циклу while",
            "pTwo": "S — його тіло",
            "pThree": "а Init — група попередніх операторів, яка задає ініціалізацію цикла",
            "textTwo": "Реально, жоден цикл не обходиться без фрагменту ініціалізації. Синтаксично було б правильно, щоб Init був би формально частиною оператора циклу. В операторі for це частково зроблено – ініціалізація лічильників є частиною циклу."
          },
          "schemeCycle": {
            "label": "Загальна схема циклу з передумовою"
          },
          "definingCycleInvariant": {
            "label": "Визначення інваріанта циклу",
            "textOne": "Предикат Inv(x, z) називається інваріантом циклу while, якщо істина наступна тріада Хоара:",
            "textTwo": "Змістовно це означає, що з істинності інваріанта циклу до початку виконання тіла циклу і з істинності умови циклу, що гарантує виконання тіла, випливає істинність інваріанта після виконання тіла циклу. Скільки б разів не виконувалося тіло циклу, його інваріант залишається істинним."
          },
          "howChooseInvariants": {
            "label": "Як вибирати інваріанти?",
            "textOne": "Для будь-якого циклу можна написати скільки завгодно багато інваріантів. Будь-яка тотожна умова (2 * 2 = 4) є інваріантом будь-якого циклу. Тому серед інваріантів виділяються так звані відповідні інваріанти циклу.",
            "textTwo": "Інваріанта називається підходящою, якщо дозволяє довести, що після завершення циклу його постумову виконано (часткова коректність циклу)."
          },
          "stepsOfProof": {
            "label": "Кроки доведення",
            "pTitle": "Щоб довести необхідно виконати наступні кроки:",
            "pTitleOne": "Крок 1.",
            "pOne": "Довести, що Inv(x, z) виконується перед першою ітерацією циклу - база індукції.",
            "pTitleTwo": "Крок 2.",
            "pTwo": "Індуктивний крок: довести, що для будь-якого позитивного n інваріанта виконується після n-ї ітерації циклу. Тобто якщо інваріанта виконувалася після (n-1) кроку, то вона буде виконана після n-го кроку."
          },
          "provingCorrectnessCycle": {
            "label": "Доведення повної коректності циклу",
            "textOne": "З циклом пов'язане ще одне важливе поняття – варіанти циклу, що використовується для доказу того, що цикл завершиться.",
            "textTwo": "Визначення варіанта циклу. Цілочисельний невід'ємний вираз Var (x, z) називається варіантом циклу, якщо виконується наступна тріада:",
            "textThree": "Змістовно це означає, що кожне виконання тіла циклу призводить до зменшення значення його варіанти. Після кінцевого числа кроків варіант досягає своєї нижньої межі, і цикл завершується. Найпростішим прикладом варіанти циклу є вираз (n - i) для циклу виду:",
            "textFour": "Цикл, для якого доведено твердження (1.1) та (1.2)",
            "textFive": "є повністю коректним."
          },
          "ruleCorrectProgramming": {
            "label": "Правило коректного програмування",
            "textOne": "Користуватися інваріантами і варіантами циклу потрібно не тільки і не стільки для того, щоб проводити формальний доказ коректності циклів. Вони сприяють написанню коректних циклів.",
            "textTwo": "Правило коректного програмування говорить: \"При написанні ожного циклу програміст повинен визначити його відповідний інваріант і варіант\".",
            "textThree": "Завдання передумов, постумов, варіантів і інваріантів циклів є такою ж частиною процесу розробки коректного методу, як і написання самого коду."
          },
          "exampleCorrectProgramming": {
            "label": "Приклад",
            "textOne": "Чи важко будувати інваріанти і варіанти циклу? Необхідна певна практика, але зазвичай розуміння алгоритму означає і розуміння інваріантів, які забезпечують коректність роботи алгоритму. Розглянемо простий приклад, нехай є цикл:",
            "textTwo": "Стверджується, що цей цикл обчислює середнє арифметичне елементів масиву. Необхідно довести або спростувати це.",
            "textThree": "Визначимо"
          },
          "exampleOfProofCorrectProgramming": {
            "label": "Приклад доведення",
            "textOne": "Вочевидь, що",
            "textTwo": "Цикл дійсно обчислює середнє арифметичне у масиві.",
            "textThree": "Детальнішу інформацію щодо теорії доведення коректності ітеративних програм можна знайти у Proving Programs Correct by Anderson, Robert B. (1979) (c. 25-138)."
          },
          "controlQuestionsAndTasks": {
            "label": "Контрольні запитання і завдання",
            "qOne": "В чому різниця між логікою висловлювань та логікою предикатів? Яка з двох логік використовується у дедуктивному доведенні коректності програм?",
            "qTwo": "Перелічіть основні правила логічного висновку у логіці предикатів.",
            "qThree": "Дайте формальне визначення частково коректному циклу.",
            "qFour": "Дайте формальне визначення повністю коректному циклу."
          },
          "examplesClassroomAndHomeworkTasks": {
            "label": "Приклади аудиторних і домашніх задач",
            "tOne": "Реалізуйте та доведіть коректність циклу обчислення максимуму у одномірному масиві.",
            "tTwo": "Дано масив елементів, що приймають одне з двох значень 1 і 2. Необхідно впорядкувати його так, щоб на початку йшли всі 1, а потім все 2. Реалізуйте це завдання, використовуючи один цикл і доведіть коректність своєї реалізації з використанням варіанти, інваріанти, перед і постумов циклу, індукції.",
            "tThree": "Відсортуйте масив методом вставок. Доведіть коректність своєї реалізації з використанням варіанти, інваріанти, перед і постумов циклу, індукції.",
            "tFour": "Знайти ітеративним способом факторіал натурального числа N. Реалізуйте це завдання, використовуючи один цикл і доведіть коректність своєї реалізації з використанням варіанти, інваріанти, перед і постумов циклу, індукції.",
            "tFive": "Знайти ітеративним способом N-е число Фібоначчі. Реалізуйте це завдання, використовуючи один цикл і доведіть коректність своєї реалізації з використанням варіанти, інваріанти, перед і постумов циклу, індукції.",
            "tSix": "Дано ціле число а і натуральне (ціле невід'ємне) число n. Обчислити а в ступені n, якщо потрібно, щоб число дій (виконуваних операторів присвоювання) було близько log n. Реалізуйте це завдання, використовуючи один цикл і доведіть коректність своєї реалізації з використанням варіанти, інваріанти, перед і постумов циклу, індукції.",
            "tSeven": "Дано два натуральних числа a і b. Обчислити їх найбільший спільний дільник. Реалізуйте це завдання, використовуючи один цикл і доведіть коректність своєї реалізації з використанням варіанти, інваріанти, перед і постумов циклу, індукції."
          }
        }
      },
      "lb": {
        "lb1": {
          "main": {
            "label": "Контрактне програмування",
            "goal": "Навчитися складати формальні специфікації реальних програм на основі парадигми «розробка за контрактом»"
          },
          "theoreticalInformation": {
            "label": "Теоретичні відомості",
            "p1": {
              "t1": "Для розробки специфікації пропонується використовувати ",
              "span": "Java Modeling Language (JML)",
              "t2": " [1, c.1-13]."
            },
            "p2": "Це мова, яка формалізує інтерфейс поведінкової специфікації, який може бути використаний для опису поведінки Java-модулей. Він комбінує підходи «design by contract», запозичений з мови Eiffel, специфікацію на основі моделі, запозичену з мов специфікації сімейства Larch, та елементи refinement calculus (числення уточнень).",
            "p3": "Для обробки jml специфікацій можна користуватися будь-якою з двох консольних утиліт: jmlspecs[1, c.9-10] (обробляє java синтаксису 1.4) або OpenJml [2, 3-20] (java 1.4-1.7) – ще знаходиться у розробці. Також можна користуватися плагіном для середовища Eclipse – JMLEclipse [3]."
          },
          "usageOpenJML": {
            "label": "Використання OpenJML",
            "p1": "Інструкції з використання OpenJML наступні.",
            "list": {
              "l1": "Розпакувати останню версію openjml у нову директорію, наприклад, ",
              "l2": "Розпакувати поруч утиліту автоматичного доведення теорем yices, наприклад до ",
              "l3-1": "Додати директорію ",
              "l3-2": " до змінної CLASSPATH.",
              "l4-1": "Створити конфігураційний файл ",
              "l4-2": " у директорії ",
              "l4-3": " з наступним вмістом"
            },
            "p2": "Правила користування утилітою детально описані в мануалі [2, 6-12].",
            "p3": "Наведемо лише основні команди.",
            "p4": "Запуск перевірки синтаксису анотацій:",
            "p5": "Запуск генерації об’єктного коду з перевіркою виконання контрактів:",
            "p6": "Запуск скомпільованого класу на виконання:",
            "p7": "Запуск статичної перевірки коду:"
          },
          "testingCustomizedUtility": {
            "label": "Тестування налаштованої утиліти",
            "p1": "Синтаксис JML детально описано в мануалі [1, c. 4-8].",
            "p2": "Для тестування налаштованої утиліти створіть файли наступного вмісту:",
            "p3": "Виконайте для файлів всі наведені команди по черзі.",
            "p4": "Проаналізуйте результат"
          },
          "problemStatement": {
            "label": "Постановка задачі",
            "l1": "Спроектуйте інтерфейси або абстрактні класи для сутностей гри",
            "l2": "Сформулюйте та виразіть на jml інваріанти перед та пост умови для всіх типів та методів.",
            "l3": "Перевірте jml-специфікацію за допомогою статичного аналізатору коду.",
            "l4": "Виправте знайдені помилки. Перевірте, що всі перед, пост умови та інваріанти насправді виконуються через тестування гри."
          },
          "variantsIndividualTasks": {
            "label": "Варіанти індивідувальних завдань",
            "l1": "Варіант 1. Гра «Сапер».",
            "l2": "Варіант 2. Гра «Шашки».",
            "l3": "Варіант 3. Гра «П’ятнашки».",
            "l4": "Варіант 4. Гра «Морський бій».",
            "l5": "Варіант 5. Гра «Хрестики-нуліки».",
            "l6": "Варіант 6. Гра «Шарики».",
            "l7": "Варіант 7. Гра «Піддавки»."
          },
          "controlQuestionsTasks": {
            "label": "Контрольні запитання і завдання",
            "l1": "Перелічіть основні конструкції jml.",
            "l2": "Перелічіть основні задачі openjml.",
            "l3": "Які утиліти входять до OpenJml та яке призначення кожної з них?"
          },
          "listOfReferences": {
            "label": "Перелік посилань",
            "eletrResource": "Електронний ресурс",
            "accessMode": "Режим доступу",
            "year": " – 19.05.2012 г. – Загол. З екрану."
          }
        },
        "lb2": {
          "main": {
            "label": "Дедуктивна верифікація програм",
            "goal": "Навчитися проводити статичну верифікацію об’єктно-орієнтованих програм на основі дедуктивної логіки та символьного виконання программ."
          },
          "preparingWorkKeY": {
            "label": "Підготовка до роботи з KeY",
            "p1": "Верифікацію програм проводитимемо за допомогою KeY [1, c. 7-14] – середовища статичної верифікації програм на JML та підмножині мови програмування Java (Java Cards API 2.2), а також на UML+OCL. Зі стандарту мови Java, яка не відноситься до Java Cards API, середовище підтримує багатовимірні масиви, цілочисельний та символьний та строковий типи даних. Тобто, якщо написати програму без динамічного завантаження класів та типу даних float, то можливо доводити її коректність за допомогою KeY.",
            "p2": "Окрім того, можна обирати між різною семантикою типу даних integer: математичне визначення, врахування можливості переповнення. В основі KeY лежить динамічна логіка (DL), яка працює на тому ж рівні, що і мова програмування (нема необхідності переводити вирази у такі формалізми, як скінченні автомати або логіки вищих порядків). DL – це модальна логіка, яка оперує формули залежно від поточного стану, до якого приводить програму виконання її операторів. Для доведення формул про позиційної логіки KeY використовую утиліти автоматичного доведення терем, такі як Simplify, Yieces, Z3 та ін.",
            "p3": "Для роботи знадобиться стабільна версія системи KeY 1.4 та JDK 1.4 або вище. Для виконання роботи реалізуйте вказане завдання на Java, проанотуйте його за допомогою JML та перевірте синтаксичну коректність анотацій за допомогою JMLEclipse аналогічно до роботи №1.",
            "p4": "Запустіть",
            "p5": "Виберіть File/Open та оберіть проанотований файл *.java. Псля аналізу коду KeY через вікно Proof Obligation Browser запропонує обрати клас, потім метод і бажане твердження для доведення (так звані proof obligations). Proof obligations формуються на основі анотацій прив’язаних до обраного методу та його контексту (інваріантів класу, де знаходиться метод). Найбільш часто використовуваними proof obligations є PreservesInv, Ensures-Post, RespectModifies."
          },
          "provingStatementsHelpKeY": {
            "label": "Доведення тверджень за допомгою KeY",
            "p1": "Для тестового прикладу завантажте виданий пакет paycard, оберіть клас PayCard.java та метод charge(int amount). Вам буде запропоновано декілька тверджень, пов’язаних з цим методом, які відповідають обмеженням розкласифікованим в анотації як два варіанті нормального або варіант помилкового виклику.",
            "p2": "Для кожного обмеження вказано перед- та пост- умову, та режим доведення (рис. 1).",
            "p3": "Обрання твердження для доведення",
            "p4": "Оберіть перший варіант normal_behavior. Твердження на Java DL буде завантажено до середовища (рис. 2).",
            "p5": "Вікно системи перед початком доведення",
            "p6": "На вкладці Proof Search Strategy треба обрати необхідні параметри, які будуть керувати процедурою автоматичного доведення твердження, як вказано на рис. 2.3.",
            "p7": "Крок 1",
            "p8": "Крок 2",
            "p9": "Налаштування KeY для проведення автоматизованого доведення",
            "p10": "Зверніть увагу, що доведення інколи не може буди виконане повністю в автоматичному режимі. Прикладом такого випадку є метод getMaximumRecord класу LogFile. В ньому інваріанта стверджує, що зміння max містить поточне більше значення у частині масиву, що вже була проаналізована до позиції j.",
            "p11": "Завантажте твердження EnsuresPost для вказаного методу. Виберіть у якості стратегії стратегії Java DL, а «Loop treatment» встановіть у None, та встановіть флажок «Autoresume strategy» , розпочніть доказ. Якщо б інваріанта була не вказана у коді, то система запросила б під час доказу ввести інваріанту або гіпотезу індукції. Коли більше не буде правил для застосування оберіть цикл while включаючи попередній блок, натисніть кнопку миші та оберіть loopInvariant. Таким чином ви задієте інваріанту та директиву «assignables» в коді. Декілька цілей залишиться відкритими після поновлення стратегії доказу. Перезапустіть стратегії та виконуйте їх доки лише одна ціль залишиться відкритою. Застосуйте зовнішній прувер – натисніть Run Yices (або інший встановлений прувер). Доведення закінчиться успішно.",
            "p12": "Аналогічним чином виконайте індивідуальне завдання.",
            "p13": "Звіт повинен містити проанотовану реалізацію класу, хід (історію) доведення кожного твердження в ній. Доказ можна зберегти, обравши Save current proof на панелі."
          },
          "variantsIndividualTasks": {
            "label": "Варіанти індивідувальних завдань",
            "l1": "Варіант 1. АТД Стек.",
            "l2": "Варіант 2. АТД Черга.",
            "l3": "Варіант 3. АТД Множина.",
            "l4": "Варіант 4. АТД Черга з приорітетами.",
            "l5": "Варіант 5. Сортування вставками.",
            "l6": "Варіант 6. Бінарний пошук.",
            "l7": "Варіант 7. Швидке сортування.",
            "l8": "Варіант 8. Сума, мінімум та максимум у масиві."
          },
          "controlQuestionsTasks": {
            "label": "Контрольні запитання і завдання",
            "l1": "Опишіть основні принципи логіки предикатів.",
            "l2": "Які існують методи логічного виведення у логіці предикатів?",
            "l3": "Опишіть основні принципи та конструкції динамічної логіки, в чому її принципока відмінність від логіки предикатів?",
            "l4": "Перелічте основні можливості KeY",
            "l5": "Перелічте основні обмеження KeY"
          },
          "listOfReferences": {
            "label": "Перелік посилань",
            "eletrResource": "Електронний ресурс",
            "accessMode": "Режим доступу",
            "year": " – 19.05.2012 г. – Загол. З екрану."
          }
        },
        "lb3": {
          "main": {
            "label": "Верифікація програм на основі темпоральної логіки",
            "goal": "Навчитися проводити верифікацію автоматних моделей програм на основі темпоральної логіки LTL."
          },
          "guidelinesForIndependentWork": {
            "p1": "Для виконання роботи використовується SPIN [1, c.4-32,6 c. 1-126] – верифікатор моделей паралельних програм, написаних на С-подібній мові Promela (Protocol Meta Language). Розроблений в дослідницькому центрі Bell Labs Джерардом Холзманном. Міжнародна асоціація ACM нагородила Spin премією ACM Software System Award за 2001 р. В 1983 році цією премією була нагороджена ОС UNIX, в 1997 р. – Tcl/Tk, в 2002 г. – мова Java."
          },
          "spinPackage": {
            "p1": "Пакет Spin дозволяє:",
            "l1": "будувати моделі паралельних програм (протоколів, драйверів, систем логічного контролю та управління) та широкого класу дискретних систем;",
            "l2": "виражати потрібні властивості їх поведінки (темпоральні властивості);",
            "l3": "автоматично шляхом натиснення кнопки перевіряти виконання темпоральних властивостей моделей на основі фомального підхода.",
            "p2": "Spin може використовуватися в двох режимах: як симулятор та як верифікатор. Під час симуляції Spin у графічному режимі виводить інформацію про одну конкретну траєкторію виконання побудованої моделі – графічне подання поведінки у вигляді діаграми «послідовності повідомлень» (Message Sequence Diagrams), що виникає під час функціонування паралельних процесів.",
            "p3": "Виконуючи симуляцію треба розуміти, що ніяка кількість симуляцій не може ",
            "p4": "довести ",
            "p5": "властивостей моделей. Для цього треба виконувати ",
            "p6": "верифікацію.",
            "p7": "Верифікатор намагається знайти контрприклад – неправильну, помилкову траєкторію поведінки, що спростовує задану користувачем властивість, через аналіз всіх можливих виконань моделі. Для цього він будує синхронну комбінацію моделі переходів системи, що перевіряєтья, та автомату Бюхі, який задає всі небажані некоректні поведінки. Якщо перетин моделей непустий – це і є контр приклад, Spin демонструє його користувачу у керованому режимі. Таким чином симуляція та верифікація у Spin тісно пов’язані."
          },
          "spinOnWindows": {
            "p1": "Для використання spin на платформі Windows знадобиться наступний мінімальний набір утиліт:",
            "l1": "mingw – windows port GNU компілятора gcc;",
            "l2": "ActiveTcl – інтерпретатор високорівневої мови написання скриптів Tcl/Tk;",
            "l3": "Graphviz – бібліотека для побудови широкого спектру графіків та діаграм;",
            "l4": "Spin – консольна утиліта для інтерпретації програм на Promela;",
            "l5": "xspin – Tcl/Tk скрипт, який реалізує графічну оболонку для полегшення та автоматизації роботи з інтерпретатором Spin.",
            "l6": "Директорії bin всіх утиліти повинні бути включені до системної змінної PATH.",
            "l7": "Синтаксис мови Promellа детально розглядався на лекції та в [1,2]. Розглянемо приклад роботи з системою. Для запуску утиліти треба створити та запустити скрипт run.bat наступного змісту:",
            "l8": "wish -f xspin525.tcl,",
            "l9": "де xspin525.tcl – скрипт графічної оболонки. Зовнішній вигляд окна візуальної оболонки наведено на рис. 1.",
            "p2": "Програму можна вводити прямо в редакторі чи завантажити з файла *.pml через File/Open. Завантажте до середовища файл altbit.pml. В ньому реалізовано протокол альтернуючого біта. В алгоритмі альтернуючого біта процес-відправник почерзі відправляє повідомлення, помічені то бітом 1, то бітом 0, і очікує відповідні підтвердження. Процес-отримувач отримує повідомлення, помічені то бітом 1, то бітом 0, і відсилає процесу-відправнику підтвердження на них.",
            "p3": "Перевірте синтаксичну коректність програми, обравши Run/Run Syntax Check. У вікно повідомлень повинно видатися «no syntax errors». Тепер можна запустити симуляцію Run/Set Simulation Parameters (рис. 2)",
            "p4": "Натисніть Start. Відкриється профіль симуляції, де у вікні Simulation Output будуть виводитися повідомлення програми, а в Sequence Chart – графічно відображатися граф взаємодії процесів(рис. 3). Симуляція підтримує 2 режими: покрокова (Single Step) та безперервна (Run)."
          },
          "correctnessModel":  {
            "p1": "Перевірка коректності моделі на основі верифікації LTL формул полягає в тому, що у виді формули LTL виражається деякі властивості її «правильної» поведінки. Всі такі властивості повинні бути перевірені по черзі одна за одною.",
            "p2": "Для перевірки моделі на основі LTL введемо до програми додаткову змінну accepted, яка буде встановлена у 0 на початку запуску і кожного разу, коли повідомлення відправляється клієнту. Accepted встановлюється в 1 тільки, якщо від клієнта прийшло підтвердження. Тепер можна виразити вимогу, що модель коректна, якщо на кожну відправку обов’язково прийде підтвердження",
            "img1": "Вікно верифікації системи",
            "p3": "Зверніть увагу, ми хочемо перевірити, що формула істина при всіх виконаннях системи, тому обрано радіокнопку “All executions” Тепер натисніть Generate – створиться процесс Never Claim, який мовою Promela містить вираження введеної формули. Тепер натисніть Run Verification. У полі Verification Results буде видано позитивний звіт за результатами перевірки: ",
            "p4": "Аналогічним чином виконайте індивідуальне завдання.",
            "p5": "Звіт повинен містити код моделі мовою Promela, автомат станів моделі, фрагмент симуляції, перелік всіх (на вашу думку) необхідних LTL формул для верифікації моделі та відповідні їм протоколи (скріншоти екранів)."
          },
          "classesOfPropertiesDistributedSystems": {
            "p1": "Традиційно властивості розподілених систем поділяються на наступні класи:",
            "l1": "властивості досяжності (reachability), встановлюють, що специфічний стан системи може бути досягнутий, загальний вид LTL формули ",
            "l2": "властивості безпеки (safety), встановлюють, що дещо небажане ніколи не станеться в системі, загальний вид LTL формули ",
            "l3": "властивості живості (liveness), встановлюють, що за деяких умов дещо “добре” в кінці кінців відбудеться при будь-якому сценарії поведінки системи, загальний вид LTL формули ",
            "l4": "властивості справедливості (fairness), встановлюють, що дещо буде виконуватися невизначено часто, загальний вид LTL формули"
          },
          "spinOperatorsLTL":  {
            "table1": "Пояснення",
            "table2": "Хоча б одного разу у майбутньому q",
            "table3": "Завжди у майбутньому q",
            "table4": "w до моменту, коли настане q"
          },
          "optionsIndividualTasks": {
            "l1": "Студент/Автомат з видачі напоїв;",
            "l2": "Банкомат/користувач",
            "l3": "Алгоритм знаходження НОД",
            "l4": "Моделювання взаємодії процесів з N розподілених кластерів для забезпечення ексклюзивного доступу процесів до спільного ресурсу.",
            "l5": "Пояснення",
            "l6": ". N кластерів з M процесами користувачів на кожному та по одному процесу менеджеру на кластер. Загальний опис ідеї протоколу: коли процес-користувач хоче отримати доступ до ресурсу, він подає заявку своєму менеджеру та чекає на надання доступу, користується ним та повинен сповістити менеджера, коли ресурс звільниться. Менеджери взаємодіють один з одним, щоб контролювати/надати кожного моменту часу лише одному клієнту доступ до ресурсу. Менеджер, який ексклюзивно володіє ресурсом, тримає так званий віртуальний токен, який він передає клієнту за запитанням. Менеджер, який отримує заявку клієнта, але не має віртуального точена повинен запросити його у інших менеджерів.",
            "c1": "Прикад заготовки процесу-клієнту наведено нижче:",
            "l7": "Додайте всі необхідні складові (інші процеси, необхідні глобальні та локальні змінні), щоб моделювання стало можливим. Створіть два кластера і по 2 процеси-клієнти на кожному.",
            "l8": "Докажіть на створеній системі наступні правила:",
            "l9": "тільки один процес може одночасно звертатися до ресурсу;",
            "l10": "відсутність голодування (якщо клієнт запросив ресурс, то рано чи пізно він його отримає).",
            "l11": "Криптографічний протокол Нідхама-Шредера. Реалізувати протокол, ввести третю сторону (зловмісника) та довести можливість зовнішньої атаки (зловмисник дізнається секрет одної із сторін)."
          },
          "controlQuestionsAndTasks":  {
            "l1": "Дайте визначення темпоральній логіці.",
            "l2": "Які конструкції відрізняють темпоральну логіку від логіки предикатів?",
            "l3": "Які підкласи темпоральних логік існують?",
            "l4": "Дайте визначення моделі Кріпке та автомату Буші, як вони пов’язані між собою.",
            "l5": "Поясніть стратегію перевірки істинності формули логіки СTL.",
            "l6": "Поясніть стратегію перевірки істинності формули логіки LTL.",
            "l7": "Які принципи роботи утиліти xSpin при вірификації моделей програм на основі темпоральної логіки?"
          },
          "listOfReferences": {
            "l1": "Шошмина, И.В. Введение в язык Promela и систему комплексной верификации Spin [Текст] / И.В. Шошмина, Ю. Г. Карпов; Санкт-Петербургский государственный политехнический университет. – СПб:Университет, 2009 г. – 66 с.",
            "l2": "G. Holzmann The Spin Model Checker: Primer and Reference Manual [Електронний ресурс] / SPIN HomePage / Режим доступу: www/URL:",
            "l3": " – 19.05.2012 г. – Загол. з екрану."
          }
        }
      },
      "other": {
        "pythonLesson": {
          "main": {
            "label": "Контрактне програмування в Python",
            "goal": "Навчитися складати формальні специфікації реальних програм на основі парадигми «розробка за контрактом»."
          },
          "mainIdeaContractProgramming": {
            "p1": "Основна ідея контрактного програмування — модель взаємодії елементів програмної системи на основі взаємних зобов'язань та вигод. Це метафора із бізнесу, де «клієнт» та «постачальник» укладають «контракт», що описує наступну поведінку:",
            "l1": "коли «клієнт» використовує «постачальника», то «клієнт» зобов'язаний задовольнити передумови, це є вигодою «постачальника», оскільки звільняє його від виконання контракту в протилежному випадку;",
            "l2": "гарантування виконання післяумови є зобов'язанням «постачальника», та є вигодою «клієнта»;",
            "l3": "виконання деякої умови на початку і в кінці є гарантуванням збереження інваріанта.",
            "p2": "Python не підтримує контрактне програмування за замовчуванням. З 2003 року, для Python є пропозиція додати нативну підтримку програмування за контрактом. Вона виражена в PEP 316 [1]. В останні роки вона почала активно оновлюватись і доповнюватись.",
            "p3": "Проте, є купа готових пакетів, які дозволяють реалізувати програмування за контрактом. До таких відносяться:",
            "l4": "Оновлення",
            "l5": "рік"
          },
          "pyContractsPackage": {
            "p1": "Для розробки специфікації контрактного програмування на Python використаємо пакет PyContracts [2, 2]. Це пакет Python, який дозволяє реалізувати підходи «design by contract». Контракти можна вказати за допомогою анотацій Python 3 або всередині рядка документації. PyContracts підтримує базову систему типів, зв’язування змінних, арифметичні обмеження, а також має кілька спеціалізованих контрактів і розширення API."
          },
          "pyContractsOnUbuntu": {
            "l1": "Перевіряємо наявність менеджеру пакетів pip3. Встановлюємо pip3, якщо він відсутній в системі:",
            "img1": "pip3 є в системі, встановлювати його не треба",
            "l2": "Створимо віртуальне середовище та активуємо його:",
            "l3": "Для запуску на Python 3.9 з папкою для віртуального середовища env:",
            "img2": "Зверніть увагу, що після виконання команди source env/bin/activate біля на початку командного рядку з’явився напис “(env)”. Це означає що ми активували віртуальне середовище і зараз знаодимось в ньому.",
            "l4": "Встановлюємо PyContracts:",
            "img3": "WARNING можна проігнорувати, так як він свідчить про те, що є більш актуальна версія pip, яку можна оновити виконавши вказану команду. Для подальшого виконання завдання його можна ігнорувати.",
            "l5": "Для перевірки, зайдемо в інтерактивний режим інтерпретатора та імпортуємо PyContracts3:",
            "img4": "Якщо немає помилки, то ми успішно встановили пакет PyContracts3 і можемо його використовувати для роботи."
          },
          "pyContractsOnWindows": {
            "l1": "Завантажуємо стабільний реліз Python з офіційного сайту:",
            "l2": ". В нашому випадку обираємо Python 3.11.0.",
            "l3": "Завантажуємо Windows installer (32-bit), якщо ви використовуєте 32-розрядну програму встановлення. Якщо ваша Windows є 64-розрядною системою, завантажуємо Windows installer (64-bit).",
            "l4": "Запускаємо програму установки, обираємо кастомізоване встановлення, обираємо додатково pip та py launcher. Натискаємо далі.",
            "l5": "В Advanced options встановлюємо прапорці «Встановити для всіх користувачів» і «Додати Python до змінних середовища». Звертаємо увагу на каталог встановлення Python, який відображається на цьому кроці. В нашому випадку це C:\\Users\\Python. Після вибору додаткових параметрів натискаємо «Встановити».",
            "l6": "Після цього в cmd.exe перевіряємо Python. Для цього пишемо python або python3. Якщо відкрилась консоль Python, то все працює.",
            "l7": "Встановлюємо virtualenv та створюємо робоче оточення. Для цього в cmd.exe виконуємо наступні команди:",
            "l8": "Встановлюємо PyContracts:",
            "l9": "Для використання пакету імпортуємо його в файл: from contracts import contract"
          },
          "installationSteps": {
            "p1": "Перші 5 кроків встановлення можна подивитись на відео:",
            "p2": "(англійська, 4хв).",
            "p3": "Крок 6 можна подивитись на відео",
            "p4": "(англійська, 6хв).",
            "p5": "Кроки 7-8 для Windows та Linux ідентичні."
          },
          "testing": {
            "p1": "Правила користування та функціональність пакету детально описані в презентації [2].",
            "code1": "Для тестування налаштованої утиліти створіть файл наступного вмісту:",
            "p2": "Код можна скопіювати з",
            "p3": "В прикладі контракти реалізовано через декоратори. Проте, їх також можна прописати, використовуючи docstrings чи анотації типів.",
            "code2": "Наприклад, метод add_weight може бути прописаний наступним чином:",
            "p4": "Використовуючи new_contract ми створили власне правило валідації даних - 'str_len_gt_zero'. Логіка цієї перевірки доволі проста: параметр має бути строкою та мати довжину більше 0. Завдяки цій функції можна створити майже будь-яке правило для валідації даних. Так як PyContracts валідує дані лише під час виконання функції, то для перевірки ми створимо два екземпляри класу: person1 та person2. Запустіть файл person.py, та виправте помилки, які виникли при валідації. Також, переробіть описані контракти через docstrings або анотації типів."
          },
          "mistakes": {
            "img1": "в __init__ параметр weight може приймати float",
            "img2": "add_country для person_1 не може приймати булеве значення",
            "img3": "при створенні person_2 передаємо пусту строку замість імені",
            "img4": "person_2.add_weight(0) викликатиме помилку, так як значення має бути більше нуля",
            "l1": "в add_country має валідуватись не тільки строка, а й перевірка на її довжину. person_2.add_country([\"\"]) має викликати помилку,",
            "l2": "@contract(returns='str_len_gt_zero') для def __str__ не має сенсу. Так як ми вже перевіряємо name на те, що він буде отримувати строку та буде не пустим. Логіка цієї функції не передбачає, що вона буде пустою. Доцільніше обмежети returns=”str”.",
            "p1": "Коли всі помилки виправлено, має відпрацювати весь код без помилок:"
          },
          "problemStatement": {
            "p1": "Спроектуйте інтерфейси або абстрактні класи для сутностей гри. Сформулюйте та виразіть на Python інваріанти перед та пост умови для всіх типів та методів. Перевірте специфікацію за допомогою PyContracts. Виправте знайдені помилки. Перевірте, що всі перед, пост умови та інваріанти насправді виконуються через тестування гри."
          },
          "individualTasks": {
            "l1": "Варіант 1. Гра «Сапер».",
            "l2": "Варіант 2. Гра «Шашки».",
            "l3": "Варіант 3. Гра «П’ятнашки».",
            "l4": "Варіант 4. Гра «Морський бій».",
            "l5": "Варіант 5. Гра «Хрестики-нуліки».",
            "l6": "Варіант 6. Гра «Шарики».",
            "l7": "Варіант 7. Гра «Піддавки»."
          },
          "controlQuestions": {
            "l1": "В чому полягає суть контрактного програмування.",
            "l2": "Як можна вимкнути PyContracts під час виконання програми?",
            "l3": "Яким чином можна задавати перед та пост умови в PyContracts? Який спосіб вам подобається більше? Чому?"
          }
        }
      }
    }
  }
}