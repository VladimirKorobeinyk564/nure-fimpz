{
  "common": {
    "header": {
      "searchText": "Пошук",
      "nav": {
        "home": "Головна",
        "labPz": "ЛБ & ПЗ"
      }
    }
  },
  "homePage": {
    "tagline": {
      "span": "ФОРМАЛЬНІ",
      "methods": "МЕТОДИ",
      "other": "ІНЖЕНЕРІЇ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ"
    },
    "subtitle": {
      "first": "Вивчайте ключові методи моделювання, розробки та верифікації складних програмних продуктів",
      "second": "для надійних та безпечних рішень."
    },
    "startBtn": "Почати вчитися"
  },
  "docsPage": {
    "fimpzLearn": "ВИВЧЕННЯ ФІМПЗ",
    "structure": "СТРУКТУРА",
    "menuTree": {
      "practicalWork": {
        "label": "Практичні роботи",
        "pz1": {
          "label": "Практичне № 1",
          "goal": "Мета заняття",
          "goal2": "Методичні вказівки"
        },
        "pz2": {
          "label": "Практичне № 2",
          "goal": "Мета заняття"
        }
      },
      "laboratoryWork": {
        "label": "Лабораторні роботи",
        "lb1": {
          "label": "Лабораторна № 1",
          "goal": "Мета заняття",
          "theoreticalInformation": "Теоретичні відомості",
          "usageOpenJML": "Використання OpenJML",
          "testingCustomizedUtility": "Тестування налаштованої утиліти",
          "problemStatement": "Постановка задачі",
          "variantsIndividualTasks": "Варіанти індивідувальних завдань",
          "controlQuestionsTasks": "Контрольні запитання і завдання",
          "listOfReferences": "Перелік посилань"
        },
        "lb2": {
          "label": "Лабораторна № 2",
          "goal": "Мета заняття",
          "preparingWorkKeY": "Підготовка до роботи з KeY",
          "provingStatementsHelpKeY": "Доведення тверджень за допомгою KeY",
          "variantsIndividualTasks": "Варіанти індивідувальних завдань",
          "controlQuestionsTasks": "Контрольні запитання і завдання",
          "listOfReferences": "Перелік посилань"
        },
        "lb3": {
          "label": "Лабораторна № 3",
          "goal": "Мета заняття"
        }
      },
      "other": {
        "label": "Інше",
        "pythonLesson": {
          "label": "Програмування Python",
          "goal": "Мета заняття"
        }
      }
    },
    "content": {
      "goalLesson": "Мета заняття",
      "lb": {
        "lb1": {
          "main": {
            "label": "Контрактне програмування",
            "goal": "Навчитися складати формальні специфікації реальних програм на основі парадигми «розробка за контрактом»"
          },
          "theoreticalInformation": {
            "label": "Теоретичні відомості",
            "p1": {
              "t1": "Для розробки специфікації пропонується використовувати ",
              "span": "Java Modeling Language (JML)",
              "t2": " [1, c.1-13]."
            },
            "p2": "Це мова, яка формалізує інтерфейс поведінкової специфікації, який може бути використаний для опису поведінки Java-модулей. Він комбінує підходи «design by contract», запозичений з мови Eiffel, специфікацію на основі моделі, запозичену з мов специфікації сімейства Larch, та елементи refinement calculus (числення уточнень).",
            "p3": "Для обробки jml специфікацій можна користуватися будь-якою з двох консольних утиліт: jmlspecs[1, c.9-10] (обробляє java синтаксису 1.4) або OpenJml [2, 3-20] (java 1.4-1.7) – ще знаходиться у розробці. Також можна користуватися плагіном для середовища Eclipse – JMLEclipse [3]."
          },
          "usageOpenJML": {
            "label": "Використання OpenJML",
            "p1": "Інструкції з використання OpenJML наступні.",
            "list": {
              "l1": "Розпакувати останню версію openjml у нову директорію, наприклад, ",
              "l2": "Розпакувати поруч утиліту автоматичного доведення теорем yices, наприклад до ",
              "l3-1": "Додати директорію ",
              "l3-2": " до змінної CLASSPATH.",
              "l4-1": "Створити конфігураційний файл ",
              "l4-2": " у директорії ",
              "l4-3": " з наступним вмістом"
            },
            "p2": "Правила користування утилітою детально описані в мануалі [2, 6-12].",
            "p3": "Наведемо лише основні команди.",
            "p4": "Запуск перевірки синтаксису анотацій:",
            "p5": "Запуск генерації об’єктного коду з перевіркою виконання контрактів:",
            "p6": "Запуск скомпільованого класу на виконання:",
            "p7": "Запуск статичної перевірки коду:"
          },
          "testingCustomizedUtility": {
            "label": "Тестування налаштованої утиліти",
            "p1": "Синтаксис JML детально описано в мануалі [1, c. 4-8].",
            "p2": "Для тестування налаштованої утиліти створіть файли наступного вмісту:",
            "p3": "Виконайте для файлів всі наведені команди по черзі.",
            "p4": "Проаналізуйте результат"
          },
          "problemStatement": {
            "label": "Постановка задачі",
            "l1": "Спроектуйте інтерфейси або абстрактні класи для сутностей гри",
            "l2": "Сформулюйте та виразіть на jml інваріанти перед та пост умови для всіх типів та методів.",
            "l3": "Перевірте jml-специфікацію за допомогою статичного аналізатору коду.",
            "l4": "Виправте знайдені помилки. Перевірте, що всі перед, пост умови та інваріанти насправді виконуються через тестування гри."
          },
          "variantsIndividualTasks": {
            "label": "Варіанти індивідувальних завдань",
            "l1": "Варіант 1. Гра «Сапер».",
            "l2": "Варіант 2. Гра «Шашки».",
            "l3": "Варіант 3. Гра «П’ятнашки».",
            "l4": "Варіант 4. Гра «Морський бій».",
            "l5": "Варіант 5. Гра «Хрестики-нуліки».",
            "l6": "Варіант 6. Гра «Шарики».",
            "l7": "Варіант 7. Гра «Піддавки»."
          },
          "controlQuestionsTasks": {
            "label": "Контрольні запитання і завдання",
            "l1": "Перелічіть основні конструкції jml.",
            "l2": "Перелічіть основні задачі openjml.",
            "l3": "Які утиліти входять до OpenJml та яке призначення кожної з них?"
          },
          "listOfReferences": {
            "label": "Перелік посилань",
            "eletrResource": "Електронний ресурс",
            "accessMode": "Режим доступу",
            "year": " – 19.05.2012 г. – Загол. З екрану."
          }
        },
        "lb2": {
          "main": {
            "label": "Дедуктивна верифікація програм",
            "goal": "Навчитися проводити статичну верифікацію об’єктно-орієнтованих програм на основі дедуктивної логіки та символьного виконання программ."
          },
          "preparingWorkKeY": {
            "label": "Підготовка до роботи з KeY",
            "p1": "Верифікацію програм проводитимемо за допомогою KeY [1, c. 7-14] – середовища статичної верифікації програм на JML та підмножині мови програмування Java (Java Cards API 2.2), а також на UML+OCL. Зі стандарту мови Java, яка не відноситься до Java Cards API, середовище підтримує багатовимірні масиви, цілочисельний та символьний та строковий типи даних. Тобто, якщо написати програму без динамічного завантаження класів та типу даних float, то можливо доводити її коректність за допомогою KeY.",
            "p2": "Окрім того, можна обирати між різною семантикою типу даних integer: математичне визначення, врахування можливості переповнення. В основі KeY лежить динамічна логіка (DL), яка працює на тому ж рівні, що і мова програмування (нема необхідності переводити вирази у такі формалізми, як скінченні автомати або логіки вищих порядків). DL – це модальна логіка, яка оперує формули залежно від поточного стану, до якого приводить програму виконання її операторів. Для доведення формул про позиційної логіки KeY використовую утиліти автоматичного доведення терем, такі як Simplify, Yieces, Z3 та ін.",
            "p3": "Для роботи знадобиться стабільна версія системи KeY 1.4 та JDK 1.4 або вище. Для виконання роботи реалізуйте вказане завдання на Java, проанотуйте його за допомогою JML та перевірте синтаксичну коректність анотацій за допомогою JMLEclipse аналогічно до роботи №1.",
            "p4": "Запустіть",
            "p5": "Виберіть File/Open та оберіть проанотований файл *.java. Псля аналізу коду KeY через вікно Proof Obligation Browser запропонує обрати клас, потім метод і бажане твердження для доведення (так звані proof obligations). Proof obligations формуються на основі анотацій прив’язаних до обраного методу та його контексту (інваріантів класу, де знаходиться метод). Найбільш часто використовуваними proof obligations є PreservesInv, Ensures-Post, RespectModifies."
          },
          "provingStatementsHelpKeY": {
            "label": "Доведення тверджень за допомгою KeY",
            "p1": "Для тестового прикладу завантажте виданий пакет paycard, оберіть клас PayCard.java та метод charge(int amount). Вам буде запропоновано декілька тверджень, пов’язаних з цим методом, які відповідають обмеженням розкласифікованим в анотації як два варіанті нормального або варіант помилкового виклику.",
            "p2": "Для кожного обмеження вказано перед- та пост- умову, та режим доведення (рис. 1).",
            "p3": "Обрання твердження для доведення",
            "p4": "Оберіть перший варіант normal_behavior. Твердження на Java DL буде завантажено до середовища (рис. 2).",
            "p5": "Вікно системи перед початком доведення",
            "p6": "На вкладці Proof Search Strategy треба обрати необхідні параметри, які будуть керувати процедурою автоматичного доведення твердження, як вказано на рис. 2.3.",
            "p7": "Крок 1",
            "p8": "Крок 2",
            "p9": "Налаштування KeY для проведення автоматизованого доведення",
            "p10": "Зверніть увагу, що доведення інколи не може буди виконане повністю в автоматичному режимі. Прикладом такого випадку є метод getMaximumRecord класу LogFile. В ньому інваріанта стверджує, що зміння max містить поточне більше значення у частині масиву, що вже була проаналізована до позиції j.",
            "p11": "Завантажте твердження EnsuresPost для вказаного методу. Виберіть у якості стратегії стратегії Java DL, а «Loop treatment» встановіть у None, та встановіть флажок «Autoresume strategy» , розпочніть доказ. Якщо б інваріанта була не вказана у коді, то система запросила б під час доказу ввести інваріанту або гіпотезу індукції. Коли більше не буде правил для застосування оберіть цикл while включаючи попередній блок, натисніть кнопку миші та оберіть loopInvariant. Таким чином ви задієте інваріанту та директиву «assignables» в коді. Декілька цілей залишиться відкритими після поновлення стратегії доказу. Перезапустіть стратегії та виконуйте їх доки лише одна ціль залишиться відкритою. Застосуйте зовнішній прувер – натисніть Run Yices (або інший встановлений прувер). Доведення закінчиться успішно.",
            "p12": "Аналогічним чином виконайте індивідуальне завдання.",
            "p13": "Звіт повинен містити проанотовану реалізацію класу, хід (історію) доведення кожного твердження в ній. Доказ можна зберегти, обравши Save current proof на панелі."
          },
          "variantsIndividualTasks": {
            "label": "Варіанти індивідувальних завдань",
            "l1": "Варіант 1. АТД Стек.",
            "l2": "Варіант 2. АТД Черга.",
            "l3": "Варіант 3. АТД Множина.",
            "l4": "Варіант 4. АТД Черга з приорітетами.",
            "l5": "Варіант 5. Сортування вставками.",
            "l6": "Варіант 6. Бінарний пошук.",
            "l7": "Варіант 7. Швидке сортування.",
            "l8": "Варіант 8. Сума, мінімум та максимум у масиві."
          },
          "controlQuestionsTasks": {
            "label": "Контрольні запитання і завдання",
            "l1": "Опишіть основні принципи логіки предикатів.",
            "l2": "Які існують методи логічного виведення у логіці предикатів?",
            "l3": "Опишіть основні принципи та конструкції динамічної логіки, в чому її принципока відмінність від логіки предикатів?",
            "l4": "Перелічте основні можливості KeY",
            "l5": "Перелічте основні обмеження KeY"
          },
          "listOfReferences": {
            "label": "Перелік посилань",
            "eletrResource": "Електронний ресурс",
            "accessMode": "Режим доступу",
            "year": " – 19.05.2012 г. – Загол. З екрану."
          }
        }
      }
    }
  }
}