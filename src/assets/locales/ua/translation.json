{
  "common": {
    "header": {
      "searchText": "Пошук",
      "nav": {
        "home": "Головна",
        "labPz": "ЛБ & ПЗ"
      }
    }
  },
  "homePage": {
    "tagline": {
      "span": "ФОРМАЛЬНІ",
      "methods": "МЕТОДИ",
      "other": "ІНЖЕНЕРІЇ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ"
    },
    "subtitle": {
      "first": "Вивчайте ключові методи моделювання, розробки та верифікації складних програмних продуктів",
      "second": "для надійних та безпечних рішень."
    },
    "startBtn": "Почати вчитися"
  },
  "docsPage": {
    "fimpzLearn": "ВИВЧЕННЯ ФІМПЗ",
    "structure": "СТРУКТУРА",
    "menuTree": {
      "practicalWork": {
        "label": "Практичні роботи",
        "pz1": {
          "label": "Практичне № 1",
          "goal": "Мета заняття",
          "goal2": "Мета заняття 2"
        },
        "pz2": {
          "label": "Практичне № 2",
          "goal": "Мета заняття"
        }
      },
      "laboratoryWork": {
        "label": "Лабораторні роботи",
        "lb1": {
          "label": "Лабораторна № 1",
          "goal": "Мета заняття",
          "theoreticalInformation": "Теоретичні відомості",
          "usageOpenJML": "Використання OpenJML",
          "testingCustomizedUtility": "Тестування налаштованої утиліти",
          "problemStatement": "Постановка задачі",
          "variantsIndividualTasks": "Варіанти індивідувальних завдань",
          "controlQuestionsTasks": "Контрольні запитання і завдання",
          "listOfReferences": "Перелік посилань"
        },
        "lb2": {
          "label": "Лабораторна № 2",
          "goal": "Мета заняття",
          "preparingWorkKeY": "Підготовка до роботи з KeY",
          "provingStatementsHelpKeY": "Доведення тверджень за допомгою KeY",
          "variantsIndividualTasks": "Варіанти індивідувальних завдань",
          "controlQuestionsTasks": "Контрольні запитання і завдання",
          "listOfReferences": "Перелік посилань"
        },
        "lb3": {
          "label": "Лабораторна № 3",
          "goal": "Мета заняття",
          "guidelinesForIndependentWork": "Методичні вказівки з організації самостійної роботи студентів",
          "spinPackage": "Пакет Spin",
          "spinOnWindows": "Використання Spin на платформі Windows",
          "correctnessModel": "Перевірка коректності моделі на основі LTL",
          "classesOfPropertiesDistributedSystems": "Класи властивостей розподілених систем",
          "spinOperatorsLTL": "Оператори Spin у LTL",
          "optionsIndividualTasks": "Варіанти індивідуальних завдань",
          "controlQuestionsAndTasks": "Контрольні запитання і завдання",
          "listOfReferences": "Перелік посилань"
        }
      },
      "other": {
        "label": "Інше",
        "pythonLesson": {
          "label": "Програмування Python",
          "goal": "Мета заняття"
        }
      }
    },
    "content": {
      "goalLesson": "Мета заняття",
      "lb": {
        "lb1": {
          "main": {
            "label": "Контрактне програмування",
            "goal": "Навчитися складати формальні специфікації реальних програм на основі парадигми «розробка за контрактом»"
          },
          "theoreticalInformation": {
            "label": "Теоретичні відомості",
            "p1": {
              "t1": "Для розробки специфікації пропонується використовувати ",
              "span": "Java Modeling Language (JML)",
              "t2": " [1, c.1-13]."
            },
            "p2": "Це мова, яка формалізує інтерфейс поведінкової специфікації, який може бути використаний для опису поведінки Java-модулей. Він комбінує підходи «design by contract», запозичений з мови Eiffel, специфікацію на основі моделі, запозичену з мов специфікації сімейства Larch, та елементи refinement calculus (числення уточнень).",
            "p3": "Для обробки jml специфікацій можна користуватися будь-якою з двох консольних утиліт: jmlspecs[1, c.9-10] (обробляє java синтаксису 1.4) або OpenJml [2, 3-20] (java 1.4-1.7) – ще знаходиться у розробці. Також можна користуватися плагіном для середовища Eclipse – JMLEclipse [3]."
          },
          "usageOpenJML": {
            "label": "Використання OpenJML",
            "p1": "Інструкції з використання OpenJML наступні.",
            "list": {
              "l1": "Розпакувати останню версію openjml у нову директорію, наприклад, ",
              "l2": "Розпакувати поруч утиліту автоматичного доведення теорем yices, наприклад до ",
              "l3-1": "Додати директорію ",
              "l3-2": " до змінної CLASSPATH.",
              "l4-1": "Створити конфігураційний файл ",
              "l4-2": " у директорії ",
              "l4-3": " з наступним вмістом"
            },
            "p2": "Правила користування утилітою детально описані в мануалі [2, 6-12].",
            "p3": "Наведемо лише основні команди.",
            "p4": "Запуск перевірки синтаксису анотацій:",
            "p5": "Запуск генерації об’єктного коду з перевіркою виконання контрактів:",
            "p6": "Запуск скомпільованого класу на виконання:",
            "p7": "Запуск статичної перевірки коду:"
          },
          "testingCustomizedUtility": {
            "label": "Тестування налаштованої утиліти",
            "p1": "Синтаксис JML детально описано в мануалі [1, c. 4-8].",
            "p2": "Для тестування налаштованої утиліти створіть файли наступного вмісту:",
            "p3": "Виконайте для файлів всі наведені команди по черзі.",
            "p4": "Проаналізуйте результат"
          },
          "problemStatement": {
            "label": "Постановка задачі",
            "l1": "Спроектуйте інтерфейси або абстрактні класи для сутностей гри",
            "l2": "Сформулюйте та виразіть на jml інваріанти перед та пост умови для всіх типів та методів.",
            "l3": "Перевірте jml-специфікацію за допомогою статичного аналізатору коду.",
            "l4": "Виправте знайдені помилки. Перевірте, що всі перед, пост умови та інваріанти насправді виконуються через тестування гри."
          },
          "variantsIndividualTasks": {
            "label": "Варіанти індивідувальних завдань",
            "l1": "Варіант 1. Гра «Сапер».",
            "l2": "Варіант 2. Гра «Шашки».",
            "l3": "Варіант 3. Гра «П’ятнашки».",
            "l4": "Варіант 4. Гра «Морський бій».",
            "l5": "Варіант 5. Гра «Хрестики-нуліки».",
            "l6": "Варіант 6. Гра «Шарики».",
            "l7": "Варіант 7. Гра «Піддавки»."
          },
          "controlQuestionsTasks": {
            "label": "Контрольні запитання і завдання",
            "l1": "Перелічіть основні конструкції jml.",
            "l2": "Перелічіть основні задачі openjml.",
            "l3": "Які утиліти входять до OpenJml та яке призначення кожної з них?"
          },
          "listOfReferences": {
            "label": "Перелік посилань",
            "eletrResource": "Електронний ресурс",
            "accessMode": "Режим доступу",
            "year": " – 19.05.2012 г. – Загол. З екрану."
          }
        },
        "lb2": {
          "main": {
            "label": "Дедуктивна верифікація програм",
            "goal": "Навчитися проводити статичну верифікацію об’єктно-орієнтованих програм на основі дедуктивної логіки та символьного виконання программ."
          },
          "preparingWorkKeY": {
            "label": "Підготовка до роботи з KeY",
            "p1": "Верифікацію програм проводитимемо за допомогою KeY [1, c. 7-14] – середовища статичної верифікації програм на JML та підмножині мови програмування Java (Java Cards API 2.2), а також на UML+OCL. Зі стандарту мови Java, яка не відноситься до Java Cards API, середовище підтримує багатовимірні масиви, цілочисельний та символьний та строковий типи даних. Тобто, якщо написати програму без динамічного завантаження класів та типу даних float, то можливо доводити її коректність за допомогою KeY.",
            "p2": "Окрім того, можна обирати між різною семантикою типу даних integer: математичне визначення, врахування можливості переповнення. В основі KeY лежить динамічна логіка (DL), яка працює на тому ж рівні, що і мова програмування (нема необхідності переводити вирази у такі формалізми, як скінченні автомати або логіки вищих порядків). DL – це модальна логіка, яка оперує формули залежно від поточного стану, до якого приводить програму виконання її операторів. Для доведення формул про позиційної логіки KeY використовую утиліти автоматичного доведення терем, такі як Simplify, Yieces, Z3 та ін.",
            "p3": "Для роботи знадобиться стабільна версія системи KeY 1.4 та JDK 1.4 або вище. Для виконання роботи реалізуйте вказане завдання на Java, проанотуйте його за допомогою JML та перевірте синтаксичну коректність анотацій за допомогою JMLEclipse аналогічно до роботи №1.",
            "p4": "Запустіть",
            "p5": "Виберіть File/Open та оберіть проанотований файл *.java. Псля аналізу коду KeY через вікно Proof Obligation Browser запропонує обрати клас, потім метод і бажане твердження для доведення (так звані proof obligations). Proof obligations формуються на основі анотацій прив’язаних до обраного методу та його контексту (інваріантів класу, де знаходиться метод). Найбільш часто використовуваними proof obligations є PreservesInv, Ensures-Post, RespectModifies."
          },
          "provingStatementsHelpKeY": {
            "label": "Доведення тверджень за допомгою KeY",
            "p1": "Для тестового прикладу завантажте виданий пакет paycard, оберіть клас PayCard.java та метод charge(int amount). Вам буде запропоновано декілька тверджень, пов’язаних з цим методом, які відповідають обмеженням розкласифікованим в анотації як два варіанті нормального або варіант помилкового виклику.",
            "p2": "Для кожного обмеження вказано перед- та пост- умову, та режим доведення (рис. 1).",
            "p3": "Обрання твердження для доведення",
            "p4": "Оберіть перший варіант normal_behavior. Твердження на Java DL буде завантажено до середовища (рис. 2).",
            "p5": "Вікно системи перед початком доведення",
            "p6": "На вкладці Proof Search Strategy треба обрати необхідні параметри, які будуть керувати процедурою автоматичного доведення твердження, як вказано на рис. 2.3.",
            "p7": "Крок 1",
            "p8": "Крок 2",
            "p9": "Налаштування KeY для проведення автоматизованого доведення",
            "p10": "Зверніть увагу, що доведення інколи не може буди виконане повністю в автоматичному режимі. Прикладом такого випадку є метод getMaximumRecord класу LogFile. В ньому інваріанта стверджує, що зміння max містить поточне більше значення у частині масиву, що вже була проаналізована до позиції j.",
            "p11": "Завантажте твердження EnsuresPost для вказаного методу. Виберіть у якості стратегії стратегії Java DL, а «Loop treatment» встановіть у None, та встановіть флажок «Autoresume strategy» , розпочніть доказ. Якщо б інваріанта була не вказана у коді, то система запросила б під час доказу ввести інваріанту або гіпотезу індукції. Коли більше не буде правил для застосування оберіть цикл while включаючи попередній блок, натисніть кнопку миші та оберіть loopInvariant. Таким чином ви задієте інваріанту та директиву «assignables» в коді. Декілька цілей залишиться відкритими після поновлення стратегії доказу. Перезапустіть стратегії та виконуйте їх доки лише одна ціль залишиться відкритою. Застосуйте зовнішній прувер – натисніть Run Yices (або інший встановлений прувер). Доведення закінчиться успішно.",
            "p12": "Аналогічним чином виконайте індивідуальне завдання.",
            "p13": "Звіт повинен містити проанотовану реалізацію класу, хід (історію) доведення кожного твердження в ній. Доказ можна зберегти, обравши Save current proof на панелі."
          },
          "variantsIndividualTasks": {
            "label": "Варіанти індивідувальних завдань",
            "l1": "Варіант 1. АТД Стек.",
            "l2": "Варіант 2. АТД Черга.",
            "l3": "Варіант 3. АТД Множина.",
            "l4": "Варіант 4. АТД Черга з приорітетами.",
            "l5": "Варіант 5. Сортування вставками.",
            "l6": "Варіант 6. Бінарний пошук.",
            "l7": "Варіант 7. Швидке сортування.",
            "l8": "Варіант 8. Сума, мінімум та максимум у масиві."
          },
          "controlQuestionsTasks": {
            "label": "Контрольні запитання і завдання",
            "l1": "Опишіть основні принципи логіки предикатів.",
            "l2": "Які існують методи логічного виведення у логіці предикатів?",
            "l3": "Опишіть основні принципи та конструкції динамічної логіки, в чому її принципока відмінність від логіки предикатів?",
            "l4": "Перелічте основні можливості KeY",
            "l5": "Перелічте основні обмеження KeY"
          },
          "listOfReferences": {
            "label": "Перелік посилань",
            "eletrResource": "Електронний ресурс",
            "accessMode": "Режим доступу",
            "year": " – 19.05.2012 г. – Загол. З екрану."
          }
        },
        "lb3": {
          "main": {
            "label": "Верифікація програм на основі темпоральної логіки",
            "goal": "Навчитися проводити верифікацію автоматних моделей програм на основі темпоральної логіки LTL.\n\n"
          },
          "guidelinesForIndependentWork": {
            "p1": "Для виконання роботи використовується SPIN [1, c.4-32,6 c. 1-126] – верифікатор моделей паралельних програм, написаних на С-подібній мові Promela (Protocol Meta Language). Розроблений в дослідницькому центрі Bell Labs Джерардом Холзманном. Міжнародна асоціація ACM нагородила Spin премією ACM Software System Award за 2001 р. В 1983 році цією премією була нагороджена ОС UNIX, в 1997 р. – Tcl/Tk, в 2002 г. – мова Java."
          },
          "spinPackage": {
            "p1": "Пакет Spin дозволяє:",
            "l1": "будувати моделі паралельних програм (протоколів, драйверів, систем логічного контролю та управління) та широкого класу дискретних систем;",
            "l2": "виражати потрібні властивості їх поведінки (темпоральні властивості);",
            "l3": "автоматично шляхом натиснення кнопки перевіряти виконання темпоральних властивостей моделей на основі фомального підхода.",
            "p2": "Spin може використовуватися в двох режимах: як симулятор та як верифікатор. Під час симуляції Spin у графічному режимі виводить інформацію про одну конкретну траєкторію виконання побудованої моделі – графічне подання поведінки у вигляді діаграми «послідовності повідомлень» (Message Sequence Diagrams), що виникає під час функціонування паралельних процесів.",
            "p3": "Виконуючи симуляцію треба розуміти, що ніяка кількість симуляцій не може ",
            "p4": "довести ",
            "p5": "властивостей моделей. Для цього треба виконувати ",
            "p6": "верифікацію.",
            "p7": "Верифікатор намагається знайти контрприклад – неправильну, помилкову траєкторію поведінки, що спростовує задану користувачем властивість, через аналіз всіх можливих виконань моделі. Для цього він будує синхронну комбінацію моделі переходів системи, що перевіряєтья, та автомату Бюхі, який задає всі небажані некоректні поведінки. Якщо перетин моделей непустий – це і є контр приклад, Spin демонструє його користувачу у керованому режимі. Таким чином симуляція та верифікація у Spin тісно пов’язані."
          },
          "spinOnWindows": {
            "p1": "Для використання spin на платформі Windows знадобиться наступний мінімальний набір утиліт:",
            "l1": "mingw – windows port GNU компілятора gcc;",
            "l2": "ActiveTcl – інтерпретатор високорівневої мови написання скриптів Tcl/Tk;",
            "l3": "Graphviz – бібліотека для побудови широкого спектру графіків та діаграм;",
            "l4": "Spin – консольна утиліта для інтерпретації програм на Promela;",
            "l5": "xspin – Tcl/Tk скрипт, який реалізує графічну оболонку для полегшення та автоматизації роботи з інтерпретатором Spin.",
            "l6": "Директорії bin всіх утиліти повинні бути включені до системної змінної PATH.",
            "l7": "Синтаксис мови Promellа детально розглядався на лекції та в [1,2]. Розглянемо приклад роботи з системою. Для запуску утиліти треба створити та запустити скрипт run.bat наступного змісту:",
            "l8": "wish -f xspin525.tcl,",
            "l9": "де xspin525.tcl – скрипт графічної оболонки. Зовнішній вигляд окна візуальної оболонки наведено на рис. 1.",
            "p2": "Програму можна вводити прямо в редакторі чи завантажити з файла *.pml через File/Open. Завантажте до середовища файл altbit.pml. В ньому реалізовано протокол альтернуючого біта. В алгоритмі альтернуючого біта процес-відправник почерзі відправляє повідомлення, помічені то бітом 1, то бітом 0, і очікує відповідні підтвердження. Процес-отримувач отримує повідомлення, помічені то бітом 1, то бітом 0, і відсилає процесу-відправнику підтвердження на них.",
            "p3": "Перевірте синтаксичну коректність програми, обравши Run/Run Syntax Check. У вікно повідомлень повинно видатися «no syntax errors». Тепер можна запустити симуляцію Run/Set Simulation Parameters (рис. 2)",
            "p4": "Натисніть Start. Відкриється профіль симуляції, де у вікні Simulation Output будуть виводитися повідомлення програми, а в Sequence Chart – графічно відображатися граф взаємодії процесів(рис. 3). Симуляція підтримує 2 режими: покрокова (Single Step) та безперервна (Run)."
          },
          "correctnessModel":  {
            "p1": "Перевірка коректності моделі на основі верифікації LTL формул полягає в тому, що у виді формули LTL виражається деякі властивості її «правильної» поведінки. Всі такі властивості повинні бути перевірені по черзі одна за одною.",
            "p2": "Для перевірки моделі на основі LTL введемо до програми додаткову змінну accepted, яка буде встановлена у 0 на початку запуску і кожного разу, коли повідомлення відправляється клієнту. Accepted встановлюється в 1 тільки, якщо від клієнта прийшло підтвердження. Тепер можна виразити вимогу, що модель коректна, якщо на кожну відправку обов’язково прийде підтвердження",
            "img1": "Вікно верифікації системи",
            "p3": "Зверніть увагу, ми хочемо перевірити, що формула істина при всіх виконаннях системи, тому обрано радіокнопку “All executions” Тепер натисніть Generate – створиться процесс Never Claim, який мовою Promela містить вираження введеної формули. Тепер натисніть Run Verification. У полі Verification Results буде видано позитивний звіт за результатами перевірки: ",
            "p4": "Аналогічним чином виконайте індивідуальне завдання.",
            "p5": "Звіт повинен містити код моделі мовою Promela, автомат станів моделі, фрагмент симуляції, перелік всіх (на вашу думку) необхідних LTL формул для верифікації моделі та відповідні їм протоколи (скріншоти екранів)."
          },
          "classesOfPropertiesDistributedSystems": {
            "p1": "Традиційно властивості розподілених систем поділяються на наступні класи:",
            "l1": "властивості досяжності (reachability), встановлюють, що специфічний стан системи може бути досягнутий, загальний вид LTL формули ",
            "l2": "властивості безпеки (safety), встановлюють, що дещо небажане ніколи не станеться в системі, загальний вид LTL формули ",
            "l3": "властивості живості (liveness), встановлюють, що за деяких умов дещо “добре” в кінці кінців відбудеться при будь-якому сценарії поведінки системи, загальний вид LTL формули ",
            "l4": "властивості справедливості (fairness), встановлюють, що дещо буде виконуватися невизначено часто, загальний вид LTL формули"
          },
          "spinOperatorsLTL":  {
            "table1": "Пояснення",
            "table2": "Хоча б одного разу у майбутньому q",
            "table3": "Завжди у майбутньому q",
            "table4": "w до моменту, коли настане q"
          },
          "optionsIndividualTasks": {
            "l1": "Студент/Автомат з видачі напоїв;",
            "l2": "Банкомат/користувач",
            "l3": "Алгоритм знаходження НОД",
            "l4": "Моделювання взаємодії процесів з N розподілених кластерів для забезпечення ексклюзивного доступу процесів до спільного ресурсу.",
            "l5": "Пояснення",
            "l6": ". N кластерів з M процесами користувачів на кожному та по одному процесу менеджеру на кластер. Загальний опис ідеї протоколу: коли процес-користувач хоче отримати доступ до ресурсу, він подає заявку своєму менеджеру та чекає на надання доступу, користується ним та повинен сповістити менеджера, коли ресурс звільниться. Менеджери взаємодіють один з одним, щоб контролювати/надати кожного моменту часу лише одному клієнту доступ до ресурсу. Менеджер, який ексклюзивно володіє ресурсом, тримає так званий віртуальний токен, який він передає клієнту за запитанням. Менеджер, який отримує заявку клієнта, але не має віртуального точена повинен запросити його у інших менеджерів.",
            "c1": "Прикад заготовки процесу-клієнту наведено нижче:",
            "l7": "Додайте всі необхідні складові (інші процеси, необхідні глобальні та локальні змінні), щоб моделювання стало можливим. Створіть два кластера і по 2 процеси-клієнти на кожному.",
            "l8": "Докажіть на створеній системі наступні правила:",
            "l9": "тільки один процес може одночасно звертатися до ресурсу;",
            "l10": "відсутність голодування (якщо клієнт запросив ресурс, то рано чи пізно він його отримає).",
            "l11": "Криптографічний протокол Нідхама-Шредера. Реалізувати протокол, ввести третю сторону (зловмісника) та довести можливість зовнішньої атаки (зловмисник дізнається секрет одної із сторін)."
          },
          "controlQuestionsAndTasks":  {
            "l1": "Дайте визначення темпоральній логіці.",
            "l2": "Які конструкції відрізняють темпоральну логіку від логіки предикатів?",
            "l3": "Які підкласи темпоральних логік існують?",
            "l4": "Дайте визначення моделі Кріпке та автомату Буші, як вони пов’язані між собою.",
            "l5": "Поясніть стратегію перевірки істинності формули логіки СTL.",
            "l6": "Поясніть стратегію перевірки істинності формули логіки LTL.",
            "l7": "Які принципи роботи утиліти xSpin при вірификації моделей програм на основі темпоральної логіки?"
          },
          "listOfReferences": {
            "l1": "Шошмина, И.В. Введение в язык Promela и систему комплексной верификации Spin [Текст] / И.В. Шошмина, Ю. Г. Карпов; Санкт-Петербургский государственный политехнический университет. – СПб:Университет, 2009 г. – 66 с.",
            "l2": "G. Holzmann The Spin Model Checker: Primer and Reference Manual [Електронний ресурс] / SPIN HomePage / Режим доступу: www/URL:",
            "l3": " – 19.05.2012 г. – Загол. з екрану."
          }
        }
      }
    }
  }
}